import { Command } from "commander";
import path from "path";
import { {{{imports}}}, {{{client}}} } from "{{{importFrom}}}"
import { promises as fsPromises } from "fs";
import fs from "fs";
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import chalk from 'chalk';
import stringify from 'json-stringify-safe';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const configFilePath = path.join(__dirname, ".config");

/**
 * Reads the config file and parses it as JSON.
 * Returns an Error if file not found.
 */
async function readConfigFile() {
  try {
    const data = await fsPromises.readFile(configFilePath, "utf-8");
    return JSON.parse(data);
  } catch (err) {
    if (err.code === "ENOENT") {
      throw new Error(
        `‚ùå No config file found. Please run configure --base-url <url>\` first.`
      );
    }
    throw err;
  }
}

/**
 * Reads the config file and parses it as JSON.
 * Returns an object (empty if file doesn't exist).
 */
async function readConfigFileOrEmpty() {
  try {
    const data = await fsPromises.readFile(configFilePath, "utf-8");
    return JSON.parse(data);
  } catch (err) {
    if (err.code === "ENOENT") {
      return {};
    }
    throw err;
  }
}


/**
 * Writes the given config object to the config file as JSON.
 */
async function writeConfigFile(config) {
  try {
    await fsPromises.writeFile(configFilePath, JSON.stringify(config, null, 2), "utf-8");
  } catch (err) {
    throw err;
  }
}

/**
 * Get the endpoint from the config file
 */
export async function getBaseUrl() {
  try {
    const config = await readConfigFile();
    return config.baseUrl || null; // return null if not set
  } catch (err) {
    console.error("Error reading endpoint:", err);
    return null;
  }
}

/**
 * Set the endpoint in the config file
 */
export async function setBaseUrl(url) {
  try {
    const config = await readConfigFileOrEmpty();
    config.baseUrl = url;
    await writeConfigFile(config);
  } catch (err) {
    console.error("Error writing endpoint:", err);
  }
}


async function getClient(token,isAuthReq){
  const baseUrl = await getBaseUrl();
  
  if(!token || !isAuthReq){
    return new {{{service}}}Client({
      endpoint: baseUrl 
    })
  }
  else{
    return new {{{service}}}Client({
      endpoint: baseUrl,
      token: { token: token },
    })
  }
}



function mergeOptionsWithJsonFile(options, jsonFilePath) {
  const jsonOptions = readJsonFile(jsonFilePath);
  
  // CLI arguments take precedence over JSON file values
  const merged = { ...jsonOptions };
  
  // Override with any CLI arguments that were provided
  Object.keys(options).forEach(key => {
    if (options[key] !== undefined) {
      merged[key] = options[key];
    }
  });
  
  return merged;
}

function readJsonFile(filePath) {
  if (path.extname(filePath).toLowerCase() !== ".json") {
    throw new Error("File must be a JSON file (.json)");
  }
  try {
    const data = fs.readFileSync(filePath, "utf8");
    return JSON.parse(data);
  } catch (err) {
    throw new Error(`Failed to read or parse JSON file: ${err.message}`);
  }
}

function validateRequiredOptions(options, requiredParams) {
  const missing = [];
  const getNestedValue = (obj, path) => {
    const parts = path.replace(/\[\]/g, "").split(/\.|\{value\}/); // handle list [] and map {value}
    let current = obj;
    for (const part of parts) {
      if (!current) return undefined;
      current = current[part];
    }
    return current;
  };

  for (const field of requiredParams) {
    // Check if this is a nested field that requires conditional validation
    const fieldParts = field.split('.');
    if (fieldParts.length > 1) {
      // Get the parent path (everything except the last part)
      const parentPath = fieldParts.slice(0, -1).join('.');
      
      // Check if the parent is also in the required params
      const parentIsRequired = requiredParams.includes(parentPath);
      
      // If parent is not required, only validate this field if parent exists
      if (!parentIsRequired) {
        const parentExists = getNestedValue(options, parentPath);
        if (parentExists === undefined || parentExists === null) {
          continue; // Skip validation if parent doesn't exist
        }
      }
    }

    const value = getNestedValue(options, field);
    if (value === undefined || value === null) {
      missing.push(field);
    }
  }

  if (missing.length > 0) {
    throw new Error(`Missing required parameters: ${missing.join(', ')}`);
  }
}


function printColoredJSON(obj, indent = 2) {
  const jsonString = stringify(obj, null, indent);
  
  // Apply colors while keeping valid JSON structure
  const colored = jsonString
    .replace(/"([^"]+)":/g, (match) => chalk.cyan(match))  // keys with quotes and colon
    .replace(/: "([^"]*)"/g, (match) => ': ' + chalk.green(match.slice(2)))  // string values
    .replace(/: (-?\d+\.?\d*)(,?)/g, (match, num, comma) => ': ' + chalk.yellow(num) + comma)  // numbers
    .replace(/: (true|false)/g, (match, bool) => ': ' + chalk.magenta(bool))  // booleans
    .replace(/: null/g, ': ' + chalk.gray('null'))  // null
    .replace(/\[Circular\]/g, chalk.red('[Circular]'));  // circular refs
  
  return colored;
}


const program = new Command()
  .name("{{{cliName}}}")
  .description("{{{cliDescription}}}")
  .version("0.0.1");