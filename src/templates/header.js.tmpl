import { Command } from "commander";
import path from "path";
import { {{{actions}}} } from "./action.js";
import { promises as fsPromises } from "fs";
import fs from "fs";
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import chalk from 'chalk';
import stringify from 'json-stringify-safe';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const configFilePath = path.join(__dirname, ".config");

/**
 * Reads the config file and parses it as JSON.
 * Returns an Error if file not found.
 */
async function readConfigFile() {
  try {
    const data = await fsPromises.readFile(configFilePath, "utf-8");
    return JSON.parse(data);
  } catch (err) {
    if (err.code === "ENOENT") {
      throw new Error(
        `‚ùå No config file found. Please run configure --base-url <url>\` first.`
      );
    }
    throw err;
  }
}

/**
 * Reads the config file and parses it as JSON.
 * Returns an object (empty if file doesn't exist).
 */
async function readConfigFileOrEmpty() {
  try {
    const data = await fsPromises.readFile(configFilePath, "utf-8");
    return JSON.parse(data);
  } catch (err) {
    if (err.code === "ENOENT") {
      return {};
    }
    throw err;
  }
}


/**
 * Writes the given config object to the config file as JSON.
 */
async function writeConfigFile(config) {
  try {
    await fsPromises.writeFile(configFilePath, JSON.stringify(config, null, 2), "utf-8");
  } catch (err) {
    throw err;
  }
}

/**
 * Get the endpoint from the config file
 */
export async function getBaseUrl() {
  try {
    const config = await readConfigFile();
    return config.baseUrl || null; // return null if not set
  } catch (err) {
    console.error("Error reading endpoint:", err);
    return null;
  }
}

/**
 * Set the endpoint in the config file
 */
export async function setBaseUrl(url) {
  try {
    const config = await readConfigFileOrEmpty();
    config.baseUrl = url;
    await writeConfigFile(config);
  } catch (err) {
    console.error("Error writing endpoint:", err);
  }
}


function readJsonFile(filePath) {
  if (path.extname(filePath).toLowerCase() !== ".json") {
    throw new Error("File must be a JSON file (.json)");
  }
  try {
    const data = fs.readFileSync(filePath, "utf8");
    return JSON.parse(data);
  } catch (err) {
    throw new Error(`Failed to read or parse JSON file: ${err.message}`);
  }
}

function printColoredJSON(obj, indent = 2) {
  const jsonString = stringify(obj, null, indent);
  
  // Apply colors while keeping valid JSON structure
  const colored = jsonString
    .replace(/"([^"]+)":/g, (match) => chalk.cyan(match))  // keys with quotes and colon
    .replace(/: "([^"]*)"/g, (match) => ': ' + chalk.green(match.slice(2)))  // string values
    .replace(/: (-?\d+\.?\d*)(,?)/g, (match, num, comma) => ': ' + chalk.yellow(num) + comma)  // numbers
    .replace(/: (true|false)/g, (match, bool) => ': ' + chalk.magenta(bool))  // booleans
    .replace(/: null/g, ': ' + chalk.gray('null'))  // null
    .replace(/\[Circular\]/g, chalk.red('[Circular]'));  // circular refs
  
  return colored;
}


const program = new Command()
  .name("{{{cliName}}}")
  .description("{{{cliDescription}}}")
  .version("{{{cliVersion}}}");