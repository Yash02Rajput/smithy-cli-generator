import fs from "fs";
import { promises as fsPromises } from "fs";
import path from "path";
import { {{{imports}}}, {{{client}}} } from "{{{importFrom}}}"
import { fileURLToPath } from 'url';
import { dirname } from 'path';


const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const configFilePath = path.join(__dirname, ".config");

/**
 * Reads the config file and parses it as JSON.
 * Returns an Error if file not found.
 */
async function readConfigFile() {
  try {
    const data = await fsPromises.readFile(configFilePath, "utf-8");
    return JSON.parse(data);
  } catch (err) {
    if (err.code === "ENOENT") {
      throw new Error(
        `‚ùå No config file found. Please run configure --base-url <url>\` first.`
      );
    }
    throw err;
  }
}


/**
 * Get the endpoint from the config file
 */
export async function getBaseUrl() {
  try {
    const config = await readConfigFile();
    return config.baseUrl || null; // return null if not set
  } catch (err) {
    console.error("Error reading endpoint:", err);
    return null;
  }
}

async function getClient(token,isAuthReq){
  const baseUrl = await getBaseUrl();
  
  if(!token || !isAuthReq){
    return new {{{service}}}Client({
      endpoint: baseUrl 
    })
  }
  else{
    return new {{{service}}}Client({
      endpoint: baseUrl,
      token: { token: token },
    })
  }
}

function readJsonFile(filePath) {
  if (path.extname(filePath).toLowerCase() !== ".json") {
    throw new Error("File must be a JSON file (.json)");
  }
  try {
    const data = fs.readFileSync(filePath, "utf8");
    return JSON.parse(data);
  } catch (err) {
    throw new Error(`Failed to read or parse JSON file: ${err.message}`);
  }
}

function mergeOptionsWithJsonFile(options, jsonFilePath) {
  const jsonOptions = readJsonFile(jsonFilePath);
  
  // CLI arguments take precedence over JSON file values
  const merged = { ...jsonOptions };
  
  // Override with any CLI arguments that were provided
  Object.keys(options).forEach(key => {
    if (options[key] !== undefined) {
      merged[key] = options[key];
    }
  });
  
  return merged;
}


function validateRequiredOptions(options, requiredParams) {
  const missing = [];
  const getNestedValue = (obj, path) => {
    const parts = path.replace(/\[\]/g, "").split(/\.|\{value\}/); // handle list [] and map {value}
    let current = obj;
    for (const part of parts) {
      if (!current) return undefined;
      current = current[part];
    }
    return current;
  };

  for (const field of requiredParams) {
    // Check if this is a nested field that requires conditional validation
    const fieldParts = field.split('.');
    if (fieldParts.length > 1) {
      // Get the parent path (everything except the last part)
      const parentPath = fieldParts.slice(0, -1).join('.');
      
      // Check if the parent is also in the required params
      const parentIsRequired = requiredParams.includes(parentPath);
      
      // If parent is not required, only validate this field if parent exists
      if (!parentIsRequired) {
        const parentExists = getNestedValue(options, parentPath);
        if (parentExists === undefined || parentExists === null) {
          continue; // Skip validation if parent doesn't exist
        }
      }
    }

    const value = getNestedValue(options, field);
    if (value === undefined || value === null) {
      missing.push(field);
    }
  }

  if (missing.length > 0) {
    throw new Error(`Missing required parameters: ${missing.join(', ')}`);
  }
}